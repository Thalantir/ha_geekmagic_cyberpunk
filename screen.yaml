esphome:
  name: small-tv-ultra-yellow
  friendly_name: Small TV
  platformio_options:
    board_build.f_cpu: 160000000L

esp8266:
  board: esp12e

logger:

api:
  reboot_timeout: 60s
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: !secret ap_ssid
    password: !secret ap_password

spi:
  clk_pin: GPIO14
  mosi_pin: GPIO13
  interface: hardware
  id: spihwd

output:
  - platform: esp8266_pwm
    pin: GPIO05
    frequency: 1000 Hz
    id: pwm_output
    inverted: true

light:
  - platform: monochromatic
    name: "Backlight"
    output: pwm_output
    restore_mode: RESTORE_AND_ON

font:
  - file: "gfonts://Roboto"
    id: font_large
    size: 50
  - file: "gfonts://Roboto"
    id: font_medium
    size: 28
  - file: "gfonts://Roboto"
    id: font_small
    size: 20

time:
  - platform: sntp
    id: esptime
    timezone: Europe/Amsterdam
    servers:
      - pool.ntp.org

sensor:
  - platform: homeassistant
    id: office_temp
    entity_id: sensor.temperature_voorkamer

  - platform: homeassistant
    id: office_nox
    entity_id: sensor.nox

  - platform: homeassistant
    id: office_voc
    entity_id: sensor.VOC

  - platform: homeassistant
    id: office_hum
    entity_id: sensor.humidity

  - platform: homeassistant
    id: office_power
    entity_id: sensor.electricity_meter_power_consumption

  - platform: homeassistant
    id: pm_1u
    entity_id: sensor.pm_1um_weight_concentration_2

  - platform: homeassistant
    id: pm_25u
    entity_id: sensor.pm_2_5um_weight_concentration_2

  - platform: homeassistant
    id: pm_4u
    entity_id: sensor.pm_4um_weight_concentration_2

  - platform: homeassistant
    id: pm_10u
    entity_id: sensor.pm_10um_weight_concentration_2

display:
  - id: my_display
    platform: mipi_spi
    model: ST7789V
    spi_id: spihwd
    dimensions:
      height: 240
      width: 240
      offset_height: 0
      offset_width: 0
    buffer_size: 12.5%
    invert_colors: true
    dc_pin: GPIO00
    reset_pin: GPIO02
    color_depth: 16
    spi_mode: mode3
    data_rate: 40000000
    auto_clear_enabled: false
    lambda: |-
      float time_sec = millis() / 1000.0;

      // Cyberpunk neon colors
      Color neon_cyan = Color(0, 255, 255);
      Color neon_magenta = Color(255, 0, 255);
      Color neon_purple = Color(138, 43, 226);
      Color neon_pink = Color(255, 20, 147);
      Color neon_green = Color(57, 255, 20);
      Color neon_orange = Color(255, 140, 0);
      Color dark_bg = Color(10, 0, 20);
      Color grid_color = Color(0, 200, 255, 180);

      // Dark cyberpunk background
      it.fill(dark_bg);

      // === CHECK WIFI AND API CONNECTION ===
      bool wifi_connected = wifi::global_wifi_component->is_connected();
      bool api_connected = api::global_api_server->is_connected();
      bool sensors_ready = !isnan(id(office_temp).state) && !isnan(id(office_nox).state);

      if (!wifi_connected || !api_connected || !sensors_ready) {
        // === BOOT SCREEN ===
        // Animated grid
        int grid_offset = (int)(time_sec * 30) % 20;
        for (int i = 0; i < 240; i += 20) {
          int pos = i - grid_offset;
          if (pos >= 0 && pos < 240) {
            it.line(0, pos, 240, pos, Color(0, 100, 150, 60));
            it.line(pos, 0, pos, 240, Color(0, 100, 150, 60));
          }
        }

        // Pulsing brackets
        int pulse = (int)(128 + 127 * sin(time_sec * 3));
        Color bracket_color = Color(0, pulse, 255);
        it.line(0, 0, 30, 0, bracket_color);
        it.line(0, 0, 0, 30, bracket_color);
        it.line(210, 0, 240, 0, bracket_color);
        it.line(240, 0, 240, 30, bracket_color);
        it.line(0, 210, 0, 240, bracket_color);
        it.line(0, 240, 30, 240, bracket_color);
        it.line(210, 240, 240, 240, bracket_color);
        it.line(240, 210, 240, 240, bracket_color);

        // Boot messages
        it.print(120, 60, id(font_medium), neon_cyan, TextAlign::CENTER, "cyb3rpunk");
        it.print(120, 90, id(font_small), neon_magenta, TextAlign::CENTER, "SYSTEM BOOT");

        // Status messages
        int status_y = 130;
        if (!wifi_connected) {
          it.print(120, status_y, id(font_small), neon_orange, TextAlign::CENTER, "> CONNECTING WIFI...");
          int dots = ((int)time_sec % 4);
          for (int i = 0; i < dots; i++) {
            it.filled_circle(140 + (i * 10), status_y + 5, 2, neon_orange);
          }
        } else if (!api_connected) {
          it.print(120, status_y - 10, id(font_small), neon_green, TextAlign::CENTER, "> WIFI CONNECTED");
          it.print(120, status_y + 10, id(font_small), neon_orange, TextAlign::CENTER, "> CONNECTING API...");
          int dots = ((int)time_sec % 4);
          for (int i = 0; i < dots; i++) {
            it.filled_circle(140 + (i * 10), status_y + 15, 2, neon_orange);
          }
        } else {
          it.print(120, status_y - 20, id(font_small), neon_green, TextAlign::CENTER, "> WIFI CONNECTED");
          it.print(120, status_y, id(font_small), neon_green, TextAlign::CENTER, "> API CONNECTED");
          it.print(120, status_y + 20, id(font_small), neon_orange, TextAlign::CENTER, "> LOADING SENSORS...");
          int dots = ((int)time_sec % 4);
          for (int i = 0; i < dots; i++) {
            it.filled_circle(150 + (i * 10), status_y + 25, 2, neon_orange);
          }
        }

        // Loading bar
        int bar_width = (int)(fmod(time_sec * 50, 200));
        it.rectangle(20, 180, 200, 10, neon_cyan);
        it.filled_rectangle(20, 180, bar_width, 10, neon_cyan);

        // Scanlines
        for (int y = 0; y < 240; y += 4) {
          it.line(0, y, 240, y, Color(0, 0, 0, 80));
        }

        return;
      }

      //  MAIN DISPLAY
      int vanish_x = 120;
      int vanish_y = 120;
      float anim_offset = time_sec * 20;

      // Lines from edges to center
      for (int i = 0; i < 240; i += 30) {
        int offset_pos = (int)(i + anim_offset) % 240;
        // From top edge to center
        it.line(offset_pos, 0, vanish_x, vanish_y, Color(grid_color.r, grid_color.g, grid_color.b, 100));
        // From bottom edge to center
        it.line(offset_pos, 240, vanish_x, vanish_y, Color(grid_color.r, grid_color.g, grid_color.b, 100));
        // From left edge to center
        it.line(0, offset_pos, vanish_x, vanish_y, Color(grid_color.r, grid_color.g, grid_color.b, 100));
        // From right edge to center
        it.line(240, offset_pos, vanish_x, vanish_y, Color(grid_color.r, grid_color.g, grid_color.b, 100));
      }

      //  TIME DISPLAY
      if (id(esptime).now().is_valid()) {
        // Glow effect for better readability
        it.strftime(122, 32, id(font_large), Color(0, 0, 0, 200), TextAlign::CENTER, "%H:%M:%S", id(esptime).now());
        it.strftime(121, 31, id(font_large), Color(0, 100, 255, 150), TextAlign::CENTER, "%H:%M:%S", id(esptime).now());
        it.strftime(120, 30, id(font_large), Color(0, 255, 255), TextAlign::CENTER, "%H:%M:%S", id(esptime).now());
      }

      //  LEFT DATA PANEL
      int panel_pulse = (int)(150 + 105 * sin(time_sec * 2.5));
      Color left_border = Color(255, panel_pulse, 147);
      it.filled_rectangle(5, 75, 125, 85, Color(20, 0, 40, 200));
      it.rectangle(5, 75, 125, 85, left_border);

      // NOx with neon orange
      it.printf(10, 75, id(font_small), neon_orange, TextAlign::LEFT, "NOx:");
      it.printf(120, 75, id(font_small), neon_cyan, TextAlign::RIGHT, "%.0f", id(office_nox).state);

      // VOC with neon green
      it.printf(10, 95, id(font_small), neon_green, TextAlign::LEFT, "VOC:");
      it.printf(120, 95, id(font_small), neon_cyan, TextAlign::RIGHT, "%.0f", id(office_voc).state);

      // Humidity with cyan
      it.printf(10, 115, id(font_small), Color(0, 191, 255), TextAlign::LEFT, "HUM:");
      it.printf(120, 115, id(font_small), neon_cyan, TextAlign::RIGHT, "%.0f%%", id(office_hum).state);

      // Power with pulsing red/magenta
      Color power_color = neon_magenta;
      if ((int)(time_sec * 4) % 2 == 0 && id(office_power).state > 1.5) {
        power_color = Color(255, 0, 100);
      }
      if (id(office_power).state >= 1.0) {
        it.printf(10, 135, id(font_small), power_color, TextAlign::LEFT, "kW:");
        it.printf(120, 135, id(font_small), neon_cyan, TextAlign::RIGHT, "%.2f", id(office_power).state);
      } else {
        it.printf(10, 135, id(font_small), power_color, TextAlign::LEFT, "W:");
        it.printf(120, 135, id(font_small), neon_cyan, TextAlign::RIGHT, "%.0f", id(office_power).state * 1000);
      }

      //  RIGHT PM PANEL - PULSING BORDER
      int panel_pulse2 = (int)(138 + 100 * sin(time_sec * 3));
      Color right_border = Color(panel_pulse2, 43, 226);
      it.filled_rectangle(130, 75, 105, 85, Color(20, 0, 40, 200));
      it.rectangle(130, 75, 105, 85, right_border);

      // PM sensors with neon purple/cyan
      it.printf(135, 75, id(font_small), Color(186, 85, 211), TextAlign::LEFT, "PM1:");
      it.printf(230, 75, id(font_small), neon_cyan, TextAlign::RIGHT, "%.0f", id(pm_1u).state);
      it.printf(135, 95, id(font_small), Color(186, 85, 211), TextAlign::LEFT, "PM2:");
      it.printf(230, 95, id(font_small), neon_cyan, TextAlign::RIGHT, "%.0f", id(pm_25u).state);
      it.printf(135, 115, id(font_small), Color(186, 85, 211), TextAlign::LEFT, "PM4:");
      it.printf(230, 115, id(font_small), neon_cyan, TextAlign::RIGHT, "%.0f", id(pm_4u).state);
      it.printf(135, 135, id(font_small), Color(186, 85, 211), TextAlign::LEFT, "PM10:");
      it.printf(230, 135, id(font_small), neon_cyan, TextAlign::RIGHT, "%.0f", id(pm_10u).state);

      //  TEMPERATURE DISPLAY - NEON STYLE
      if (!isnan(id(office_temp).state)) {
        Color temp_color;
        if (id(office_temp).state < 20) {
          temp_color = neon_cyan;
        } else if (id(office_temp).state <= 25) {
          temp_color = neon_orange;
        } else {
          temp_color = neon_magenta;
        }

        // Neon border - PULSING
        int temp_pulse = (int)(200 + 55 * sin(time_sec * 4));
        Color temp_border = Color(temp_color.r * temp_pulse / 255, temp_color.g * temp_pulse / 255, temp_color.b * temp_pulse / 255);
        it.filled_rectangle(40, 165, 180, 65, Color(20, 0, 40, 220));
        it.rectangle(40, 165, 180, 65, temp_border);
        it.rectangle(41, 166, 178, 63, temp_color);

        // Digital thermometer bars
        int temp_bars = (int)(id(office_temp).state / 3);
        for (int i = 0; i < temp_bars && i < 10; i++) {
          it.filled_rectangle(50, 220 - (i * 5), 15, 3, temp_color);
        }

        // Temperature value
        it.printf(140, 195, id(font_large), temp_color, TextAlign::CENTER, "%.1fÂ°C", id(office_temp).state);
      }
      else {
        it.print(120, 195, id(font_small), neon_cyan, TextAlign::CENTER, "> BOOTING SYSTEMS...");
      }
